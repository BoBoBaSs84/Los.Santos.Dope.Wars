<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(TargetDir)LSDW.Domain.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="LSDW.Domain.Models" #>
<#@ output extension="Designer.cs" #>
#pragma warning disable CS1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using GTA;
using LSDW.Abstractions.Infrastructure.Services;
using LSDW.Domain.Models;

namespace LSDW.Infrastructure.Services;

internal sealed partial class SettingsService : ISettingsService
{
	/// <summary>
	/// Initializes a instance of the settings service class.
	/// </summary>
	internal SettingsService()
	{
		string iniFilePath = Path.Combine(AppContext.BaseDirectory, Settings.IniFileName);
		_scriptSettings = ScriptSettings.Load(iniFilePath);

<# foreach (Type nestedType in nestedTypes) { #>
    <#= nestedType.Name #><#= nameof(Settings) #> = new <#= nestedType.Name #><#= nameof(Settings) #>(_scriptSettings);
<# } #>
    
    Load();
    Save();
	}

<# foreach (Type nestedType in nestedTypes) { #>
  public I<#= nestedType.Name #><#= nameof(Settings) #> <#= nestedType.Name #><#= nameof(Settings) #> { get; }
<# } #>

  private void Load()
  {
<# foreach (Type nestedType in nestedTypes) { 
List<PropertyInfo> properties = nestedType.GetProperties().ToList();
foreach (PropertyInfo prop in properties) { #>
    <#= TypeNameOrAlias(prop.PropertyType) #> <#= prop.Name.ToLower() #> = <#= nestedType.Name #><#= nameof(Settings) #>.Get<#= prop.Name #>();
    <#= nestedType.Name #><#= nameof(Settings) #>.Set<#= prop.Name #>(<#= prop.Name.ToLower() #>);
<# }} #>
  }
}
<# foreach (Type nestedType in nestedTypes) { #>

internal sealed class <#= nestedType.Name #><#= nameof(Settings) #> : I<#= nestedType.Name #><#= nameof(Settings) #>
{
  private readonly ScriptSettings _scriptSettings;

  internal <#= nestedType.Name #><#= nameof(Settings) #>(ScriptSettings scriptSettings)
    => _scriptSettings = scriptSettings;

<# List<PropertyInfo> properties = nestedType.GetProperties().ToList();
foreach (PropertyInfo prop in properties) { #>
<# if (TypeNameOrAlias(prop.PropertyType) != "bool") {#>
  public List<<#= TypeNameOrAlias(prop.PropertyType) #>> Get<#= prop.Name #>Values()
    => <#= nameof(Settings) #>.<#= nestedType.Name #>.Get<#= prop.Name #>Values();
<# } #>

  public <#= TypeNameOrAlias(prop.PropertyType) #> Get<#= prop.Name #>()
    => _scriptSettings.GetValue("<#= nestedType.Name.ToUpper() #><#= typeof(Settings).Name.ToUpper() #>", "<#= prop.Name.ToUpper() #>", <#= nameof(Settings) #>.<#= nestedType.Name #>.<#= prop.Name #>);

	public void Set<#= prop.Name #>(<#= TypeNameOrAlias(prop.PropertyType) #> value)
  {
		_scriptSettings.SetValue("<#= nestedType.Name.ToUpper() #><#= typeof(Settings).Name.ToUpper() #>", "<#= prop.Name.ToUpper() #>", value);
		<#= nameof(Settings) #>.<#= nestedType.Name #>.<#= prop.Name #> = value;
  }
<# } #>
}
<# } #>
<#+
List<Type> nestedTypes = typeof(Settings).GetNestedTypes().ToList();

private static Dictionary<Type, string> _typeAlias = new Dictionary<Type, string>
{
    { typeof(bool), "bool" },
    { typeof(byte), "byte" },
    { typeof(char), "char" },
    { typeof(decimal), "decimal" },
    { typeof(double), "double" },
    { typeof(float), "float" },
    { typeof(int), "int" },
    { typeof(long), "long" },
    { typeof(object), "object" },
    { typeof(sbyte), "sbyte" },
    { typeof(short), "short" },
    { typeof(string), "string" },
    { typeof(uint), "uint" },
    { typeof(ulong), "ulong" },
    { typeof(void), "void" }
};

private static string TypeNameOrAlias(Type type)
{
    if (_typeAlias.TryGetValue(type, out string alias))
        return alias;

    return type.Name;
}
#>