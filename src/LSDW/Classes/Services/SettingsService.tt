<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(TargetDir)LSDW.Core.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="LSDW.Core.Classes" #>
<#@ output extension=".cs" #>
using GTA;
using LSDW.Core.Classes;
using LSDW.Factories;
using LSDW.Interfaces.Services;
using Dealer = LSDW.Core.Classes.Settings.Dealer;
using Market = LSDW.Core.Classes.Settings.Market;
using Player = LSDW.Core.Classes.Settings.Player;

namespace LSDW.Classes.Services;

/// <summary>
/// The settings service class.
/// </summary>
/// <remarks>
/// Wrapper for the <see cref="ScriptSettings"/>.
/// </remarks>
public sealed class SettingsService : ISettingsService
{
	private readonly ILoggerService _loggerService;
	private readonly ScriptSettings _scriptSettings;

	/// <summary>
	/// Initializes a instance of the settings service class.
	/// </summary>
	public SettingsService()
	{
		string settingsFileName = Path.Combine(AppContext.BaseDirectory, Settings.SettingsFileName);
		_loggerService = ServiceFactory.CreateLoggerService();
		_scriptSettings = ScriptSettings.Load(settingsFileName);
    
    Load();
    Save();
	}

  public void Load()
  {
<# foreach (Type nestedType in nestedTypes) { 
List<PropertyInfo> properties = nestedType.GetProperties().ToList();
foreach (PropertyInfo prop in properties) { #>
    <#= nestedType.Name #>.<#= prop.Name #> = Get<#= prop.Name #>();
<# }} #>
  }

  public void Save()
    => _scriptSettings.Save();
<# foreach (Type nestedType in nestedTypes) { 
List<PropertyInfo> properties = nestedType.GetProperties().ToList();
foreach (PropertyInfo prop in properties) { #>

	public <#= TypeNameOrAlias(prop.PropertyType) #> Get<#= prop.Name #>()
  {
    <#= TypeNameOrAlias(prop.PropertyType) #> value = _scriptSettings.GetValue(nameof(<#= nestedType.Name #>), nameof(<#= nestedType.Name #>.<#= prop.Name #>), <#= prop.GetValue(this, null).ToString().ToLowerInvariant() #>);
    return value;
  }

	public void Set<#= prop.Name #>(<#= TypeNameOrAlias(prop.PropertyType) #> value)
  {
		_scriptSettings.SetValue(nameof(<#= nestedType.Name #>), nameof(<#= nestedType.Name #>.<#= prop.Name #>), value);
		<#= nestedType.Name #>.<#= prop.Name #> = value;
  }
<# }} #>
}
<#+
List<Type> nestedTypes = typeof(Settings).GetNestedTypes().ToList();
// This is the set of types from the C# keyword list.
static Dictionary<Type, string> _typeAlias = new Dictionary<Type, string>
{
    { typeof(bool), "bool" },
    { typeof(byte), "byte" },
    { typeof(char), "char" },
    { typeof(decimal), "decimal" },
    { typeof(double), "double" },
    { typeof(float), "float" },
    { typeof(int), "int" },
    { typeof(long), "long" },
    { typeof(object), "object" },
    { typeof(sbyte), "sbyte" },
    { typeof(short), "short" },
    { typeof(string), "string" },
    { typeof(uint), "uint" },
    { typeof(ulong), "ulong" },
    // Yes, this is an odd one.  Technically it's a type though.
    { typeof(void), "void" }
};

static string TypeNameOrAlias(Type type)
{
    // Lookup alias for type
    if (_typeAlias.TryGetValue(type, out string alias))
        return alias;

    // Default to CLR type name
    return type.Name;
}
#>