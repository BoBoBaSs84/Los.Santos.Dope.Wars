<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(TargetDir)LSDW.Abstractions.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="LSDW.Abstractions.Models" #>
<#@ output extension="Designer.cs" #>
#pragma warning disable CS1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using LemonUI.Menus;
using LSDW.Presentation.Items;
using RESX = LSDW.Presentation.Properties.Resources;

namespace LSDW.Presentation.Menus;

internal sealed partial class SettingsMenu
{
	private void AddMenuItems()
	{
<# foreach (Type nestedType in nestedTypes) {
List<PropertyInfo> properties = nestedType.GetProperties().ToList();
foreach (PropertyInfo prop in properties) { #>
<# if (TypeNameOrAlias(prop.PropertyType) != "bool") {#>
    SettingListItem<<#= TypeNameOrAlias(prop.PropertyType) #>> <#= nestedType.Name.ToLower() #><#= prop.Name #>Item = new(RESX.UI_<#= nameof(Settings) #>_<#= nestedType.Name #>_<#= prop.Name #>_Title)
    {
      Description = RESX.UI_<#= nameof(Settings) #>_<#= nestedType.Name #>_<#= prop.Name #>_Description,
      Items = _settingsService.<#= nestedType.Name #><#= nameof(Settings) #>.Get<#= prop.Name #>Values(),
      SelectedItem = _settingsService.<#= nestedType.Name #><#= nameof(Settings) #>.Get<#= prop.Name #>()
    };
    <#= nestedType.Name.ToLower() #><#= prop.Name #>Item.ItemChanged += On<#= nestedType.Name #><#= prop.Name #>ItemChanged;
    Add(<#= nestedType.Name.ToLower() #><#= prop.Name #>Item);
<# } else { #>
    SettingCheckboxItem <#= nestedType.Name.ToLower() #><#= prop.Name #>Item = new(RESX.UI_<#= nameof(Settings) #>_<#= nestedType.Name #>_<#= prop.Name #>_Title)
    {
      Description = RESX.UI_<#= nameof(Settings) #>_<#= nestedType.Name #>_<#= prop.Name #>_Description,
      Checked = _settingsService.<#= nestedType.Name #><#= nameof(Settings) #>.Get<#= prop.Name #>()
    };
    <#= nestedType.Name.ToLower() #><#= prop.Name #>Item.CheckboxChanged += On<#= nestedType.Name #><#= prop.Name #>ItemCheckboxChanged;
    Add(<#= nestedType.Name.ToLower() #><#= prop.Name #>Item);
<# }}} #>
	}
<# foreach (Type nestedType in nestedTypes) { 
List<PropertyInfo> properties = nestedType.GetProperties().ToList();
foreach (PropertyInfo prop in properties) { #>
<# if (TypeNameOrAlias(prop.PropertyType) != "bool") {#>
  private void On<#= nestedType.Name #><#= prop.Name #>ItemChanged(object sender, ItemChangedEventArgs<<#= TypeNameOrAlias(prop.PropertyType) #>> args)
  {
    if (sender is not SettingListItem<<#= TypeNameOrAlias(prop.PropertyType) #>> item)
      return;
    _settingsService.<#= nestedType.Name #><#= nameof(Settings) #>.Set<#= prop.Name #>(item.SelectedItem);
  }
<# } else { #>
  private void On<#= nestedType.Name #><#= prop.Name #>ItemCheckboxChanged(object sender, EventArgs args)
  {
    if (sender is not SettingCheckboxItem item)
      return;
    _settingsService.<#= nestedType.Name #><#= nameof(Settings) #>.Set<#= prop.Name #>(item.Checked);
  }  
<# }}} #>
}
<#+
List<Type> nestedTypes = typeof(Settings).GetNestedTypes().ToList();

private static Dictionary<Type, string> _typeAlias = new Dictionary<Type, string>
{
    { typeof(bool), "bool" },
    { typeof(byte), "byte" },
    { typeof(char), "char" },
    { typeof(decimal), "decimal" },
    { typeof(double), "double" },
    { typeof(float), "float" },
    { typeof(int), "int" },
    { typeof(long), "long" },
    { typeof(object), "object" },
    { typeof(sbyte), "sbyte" },
    { typeof(short), "short" },
    { typeof(string), "string" },
    { typeof(uint), "uint" },
    { typeof(ulong), "ulong" },
    { typeof(void), "void" }
};

private static string TypeNameOrAlias(Type type)
{
    if (_typeAlias.TryGetValue(type, out string alias))
        return alias;

    return type.Name;
}
#>